from django.shortcuts import render_to_response, get_object_or_404
from django.http import HttpResponseRedirect, HttpResponse
from django.core.urlresolvers import reverse
from django.template import RequestContext, Context, loader
from django.contrib.auth.decorators import login_required
from cal_forms import NewCalendar
from sys import exc_info
from psugle.calresource import CalendarResource
import os

@login_required
def index(request):
  #if form has been submitted
  if request.method == 'POST':
    form = NewCalendar( request.POST )

    how_far = [] #debug

    #if form valid, take all of the vars from it
    if form.is_valid():
      calendar_name = form.cleaned_data['calendar_name']
      requestor_1 = form.cleaned_data['requestor_1']
      requestor_2 = form.cleaned_data['requestor_2']
      how_far.append('form_processed') #debug
      try:
        client = CalendarResource( 'gtest.pdx.edu' )
        how_far.append( 'client_created' ) #debug
        #create calendar if it doens't already exist
        calendar_already_exists = False
        existing_cals = client.get_all_resources()
        how_far.append( 'all resourced retrieved' ) #debug
        for cal in existing_cals:
            if cal['name'] == calendar_name:
                calendar_already_exists = True
        if not calendar_already_exists:
            how_far.append( 'new calendar about to be created' ) #debug
            client.create( name=str(calendar_name) )
            how_far.append( 'new calendar created' ) #debug
        #add requestors if they aren't already owners
        requestor_1_already_owner = False
        requestor_2_already_owner = False
        acl = client.get_acl_by_name( calendar_name )
        how_far.append( 'acl for cal retrieved' ) #debug
        for entry in acl:
            if entry[0] == (requestor_1+'@'+str(client.domain)):
                requestor_1_already_owner = True
        if (requestor_1 != '') and (not requestor_1_already_owner):
          client.set_owner_by_name( name=str(calendar_name),owner=str(requestor_1) )
          how_far.append('requestor1 set') #debug
        acl = client.get_acl_by_name( calendar_name )
        how_far.append('acl retrieved (2nd time)') #debug
        for entry in acl:
            if entry[0] == (requestor_2+'@'+str(client.domain)):
                requestor_2_already_owner = True
        if (requestor_2 != '') and (not requestor_2_already_owner):
          client.set_owner_by_name( name=str(calendar_name),owner=str(requestor_2) )
          how_far.append( 'requestor2 set' ) #debug
        #create the success message
        success_message = ''
        if calendar_already_exists:
            success_message += calendar_name + ' (existing calendar)'
        else:
            success_message += calendar_name + ' (new calendar created)'
 
        #display success string
        return success( success_message, requestor_1, requestor_2, calendar_name )
      except:
          return failure( str(exc_info()[1]) + '\n<br/>calendar name: '+str(calendar_name)+'\n<br/>requestor1: '+str(requestor_1)+'\n<br/>requestor2: '+str(requestor_2)+'\n<br/>how far: '+str( how_far ) )
  
    #if form not valid
    else:
      return failure( 'form not valid...' )

  #if form HASN'T been submitted
  else:
    form = NewCalendar()
  template = loader.get_template( 'index.html' )
  context = Context()
  return render_to_response( 'index.html', { 'form':form }, context_instance=RequestContext(request)  )

#@login_required
def success( success_message, requestor_1, requestor_2, calendar_name ):
  '''render the template with all of the correct fields'''
  return render_to_response('success.html', { 'success_message': success_message, \
    'requestor_1': requestor_1, 'requestor_2': requestor_2, 'calendar_name':calendar_name } )

#@login_required
def failure( error_msg ):
  '''render the failure template wih the error message'''
  return render_to_response( 'failure.html', { 'error_msg': error_msg } )

#@login_required
def static( request, file ):
  try:
    print os.getcwd() #debug
    print os.access(str('/static/'+file), os.F_OK )
    static_file = open( str('/static/'+file) , 'r' )
    fs = static_file.read()
    return HttpResponse( fs )
  except:
    return HttpResponse( str( str(exc_info()[1]) ) )
